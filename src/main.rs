use std::path::PathBuf;

use clap::{Parser, Subcommand};
use clap_verbosity_flag::Verbosity;

use log;
use std::fs::{File, OpenOptions};
use std::io::{BufReader, BufWriter};
use std::time::Instant;

use anyhow::{anyhow, Ok, Result};
use file_cipher;
use micro_uecc_safe;

#[derive(Parser)]
#[command(version = "1.1.1")]
#[command(about = "encrypt and decrypt files", long_about = None)]
struct Cli {
    #[clap(subcommand)]
    command: Command,

    // #[arg(long, short, conflicts_with = "xor", help = "generate key pair")]
    // generatekey: bool,
    #[command(flatten)]
    verbose: Verbosity,
}

#[derive(Subcommand)]
enum Command {
    Xor {
        #[arg(long, short, help = "input file path or input directory")]
        input: PathBuf,

        #[arg(long, short, help = "output directory")]
        output: PathBuf,

        #[arg(
            long,
            short,
            default_value = "false",
            help = "decrypt the input file. The default value is false, which is encrypted"
        )]
        decrypt: bool,

        #[arg(
            long,
            short,
            help = "each byte of the input file is xor evaluated against this value, and it can't be zero"
        )]
        xor: u8,
    },

    Aes {
        #[arg(long, short, help = "input file path or input directory")]
        input: PathBuf,

        #[arg(long, short, help = "output directory")]
        output: PathBuf,

        #[arg(
            long,
            short,
            default_value = "false",
            help = "decrypt the input file. The default value is false, which is encrypted"
        )]
        decrypt: bool,

        #[arg(
            long,
            short,
            help = "The public key generated by the generate-key command is required for encryption. The private key generated by the generate-key command is required for decryption."
        )]
        key: String,
    },

    GenerateKey,
}

fn processing_file<C: file_cipher::cipher::Cipher, P: AsRef<std::path::Path>>(
    cipher: &C,
    input: P,
    output: P,
    encrypt: bool,
) -> Result<()> {
    let input = input.as_ref();
    let output = output.as_ref();
    let in_file = File::open(input)?;

    let mut br = BufReader::new(in_file);
    let mut bw: BufWriter<File>;

    let title = if encrypt { "encrypt" } else { "decrypt" };
    log::info!("{} input file: {}", title, input.to_str().unwrap());
    log::info!("{} output file: {}", title, output.to_str().unwrap());
    let begin_time = Instant::now();
    if encrypt {
        let out_file = OpenOptions::new().create(true).write(true).open(output)?;
        bw = BufWriter::new(out_file);
        cipher.encrypt(&mut br, &mut bw)?;
    } else {
        let out_file = OpenOptions::new().create(true).write(true).open(output)?;
        bw = BufWriter::new(out_file);
        cipher.decrypt(&mut br, &mut bw)?;
    }

    let end_time = Instant::now();
    log::trace!("elapsed time: {:?}", end_time.duration_since(begin_time));
    Ok(())
}

fn processing<C: file_cipher::cipher::Cipher>(
    cipher: &C,
    input: &PathBuf,
    output: &PathBuf,
    encrypt: bool,
) -> anyhow::Result<()> {
    if !output.exists() {
        let copied = output.clone();
        std::fs::create_dir_all(copied.as_path())?;
        log::info!("Create output directory: {}", &copied.to_str().unwrap());
    }

    if input.is_dir() {
        for entry in std::fs::read_dir(input)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_dir() {
                continue;
            }

            if path.ends_with(".DS_Store") {
                continue;
            }

            let filename = path.file_name().unwrap();
            let mut _output = output.clone();
            _output.push(filename);
            match processing_file(cipher, path, _output.clone(), encrypt) {
                Err(ref err) => {
                    log::error!("{}", err);
                    std::fs::remove_file(_output)?;
                }
                _ => {}
            }
        }
    } else {
        let filename = input.file_name().unwrap();
        let mut _output = output.clone();
        _output.push(filename);
        match processing_file(cipher, input, &_output.clone(), encrypt) {
            Err(ref err) => {
                log::error!("{}", err);
                std::fs::remove_file(_output)?;
            }
            _ => {}
        }
    }

    Ok(())
}
fn main() -> Result<()> {
    let cli = Cli::parse();

    env_logger::Builder::new()
        .filter_level(cli.verbose.log_level_filter())
        .init();

    match cli.command {
        Command::GenerateKey => {
            let key = micro_uecc_safe::uecc_mkae_key_with_secp256k1()?;
            println!("private_key: {}", key.private_key);
            println!("public_key: {}", key.public_key);
            return Ok(());
        }
        Command::Xor {
            input,
            output,
            decrypt,
            xor,
        } => {
            if xor == 0 {
                log::error!("The xor parameter cannot be zero");
                return Err(anyhow!("The xor parameter cannot be zero"));
            }

            let cipher = file_cipher::xor::XorCipher::new(xor);
            processing(&cipher, &input, &output, !decrypt)?;
        }
        Command::Aes {
            input,
            output,
            decrypt,
            key,
        } => {
            let cipher = file_cipher::aes_ecc::AesECCCipher::new(&key);
            processing(&cipher, &input, &output, !decrypt)?;
        }
    }
    Ok(())
}
